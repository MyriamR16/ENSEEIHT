#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <fcntl.h>
#include <stdbool.h>

//Dans ce cas là, ça devrait marcher car on crée le fils après avoir 
//crée le tube. Ainsi, le père et le fils partagent les deux le même tube.

void main (int argc, char *argv[]){
    static int p[2]; 
    int entier = atoi(argv[1]); 
    int entier_lu;
    int pid;
    
    //Création du tube avant le fils
    if (pipe(p)== -1){
        //Cas d'erreur : le pipe ne se fait pas.
        perror("pipe");
        exit(EXIT_FAILURE);
    }; 

    //On bloque l'accès lecture au père car celui ci se contente d'écrire dans le tube.
    if (write(p[1], &entier ,sizeof(entier)) == -1) {
        //Cas d'erreur de l'écriture dans le tube de la part du père.
        perror("Problème lors de l'écriture");
        exit(EXIT_FAILURE);
     }

    
    //Création du fils
    pid = fork(); 
    
    if (pid == -1) {
        //Cas d'erreur : le fork ne se fait pas.
        perror ("fork");
        exit(EXIT_FAILURE);   
        
    }else if (pid > 0) {
        //Père
        
        //On bloque l'accès lecture et écriture au père car celui ci a déjà écrit dans le tube.
        close(p[0]);
        close(p[1]); 
        
    }else {
        //fils
        
        //On bloque l'accès écriture au fils car celui ci se contente de lire 
        //ce qu'il y a dans le tube.
        close(p[1]);
        
        if (read(p[0], &entier_lu, sizeof(entier_lu)) == -1) {
            //Cas d'erreur de lecture dans le tube de la part du fils.
            perror("Problème lors de la lecture");
            exit(EXIT_FAILURE);
        }
        //On ferme l'accès lecture après avoir écrit dans le tube.
        close(p[0]);
        
        // Affichage
        printf("L'entier lu dans le tube est : %d\n", entier_lu);
    }
}
