#include <stdio.h>
#include <stdlib.h>
#include "readcmd.h"
#include <stdbool.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>
#include <unistd.h>
#include <fcntl.h>

#define TAILLE_TABLEAU_TUBES 6

bool AvantPlanFini = false;
pid_t retour;

void traitement_SIGCHLD (int sig) {
    //printf("Je suis le processus %d, et j'ai reçu le signal %d \n", getpid(),sig);
    int status;
    pid_t pid;

    while ((pid = waitpid(-1, &status, WNOHANG|WUNTRACED|WCONTINUED))>0){
       if (WIFEXITED(status)) {
          printf("Le processus %d s'est terminé avec le code de retour %d suite au signal %d.\n", pid,WEXITSTATUS(status),sig);
       } else if (WIFSIGNALED(status)) {
          printf("Le processus %d s'est terminé à cause d'un signal avec le numéro %d suite au signal %d.\n", pid,WTERMSIG(status),sig);
       } else if (WIFSTOPPED(status)) {
          printf("Le processus %d a été suspendu par un signal SIGSTOP  suite au signal %d.\n", pid,sig);
       } else if (WIFCONTINUED(status)) {
          printf("Le processus %d a été repris par un signal SIGCONT suite au signal %d.\n", pid,sig);
       } 
   
       if (retour == pid){
         AvantPlanFini = true; 
       }
    }
    return;  
}

void traitement_SIGINT (){
    printf("\nControle C. Affichage du prompt.\n");
    
}

void traitement_SIGTSTP (){
    printf("\nControle Z. Affichage du prompt.\n");
    
}

int main(void) {
    struct sigaction action;
    
    //SIGCHLD
    action.sa_handler = traitement_SIGCHLD; 
    sigemptyset(&action.sa_mask); 
    action.sa_flags = SA_RESTART;
    sigaction(SIGCHLD, &action, NULL);
    


    //SIGINT
    //action.sa_handler = traitement_SIGINT; 
    //sigemptyset(&action.sa_mask); 
    //action.sa_flags = SA_RESTART;
    //sigaction(SIGINT, &action, NULL);
    //signal(SIGINT, SIG_IGN);
     
    //SIGTSTP
    //action.sa_handler = traitement_SIGTSTP; 
    //sigemptyset(&action.sa_mask); 
    //action.sa_flags = SA_RESTART;
    //sigaction(SIGTSTP, &action, NULL);
    //signal(SIGTSTP, SIG_IGN);
    
    //signal(SIGINT,SIG_IGN); 
    //signal(SIGTSTP,SIG_IGN);  
    
    sigset_t mask;
    sigemptyset(&mask);
    sigaddset(&mask,SIGINT); //SIGINT pour le controle C
    sigaddset(&mask,SIGTSTP);//SIGTSTP pour le controle Z
    sigprocmask(SIG_BLOCK, &mask, NULL);
    
    bool fini= false;

    while (!fini) {
        printf("> ");
        struct cmdline *commande= readcmd();

        if (commande == NULL) {
            // commande == NULL -> erreur readcmd()
            perror("erreur lecture commande \n");
            exit(EXIT_FAILURE);
    
        } else {

            if (commande->err) {
                // commande->err != NULL -> commande->seq == NULL
                printf("erreur saisie de la commande : %s\n", commande->err);
        
            } else {
            
                    int tubes[TAILLE_TABLEAU_TUBES][2];
                    int nbCommandes = 0;
                
                    //On calcule le nombre de commandes à étudier.
                    while (commande->seq[nbCommandes]){
                        //Tant qu'on atteint pas la derniere commande
                        nbCommandes++;
                    }
                
                    //On détermine le nombre de tubes totaux dans le tableau
                    int nbTubes = nbCommandes - 1;
                
                    //Création des nbTubes 
                    for (int i = 0; i<nbTubes ; i++) {
                        if (pipe(tubes[i]) == -1) {
                                printf("Erreur: création du tube\n");
                                exit(EXIT_FAILURE);
                        }
                    } 
           
                    

                /* Pour le moment le programme ne fait qu'afficher les commandes 
                   tapees et les affiche à l'écran. 
                   Cette partie est à modifier pour considérer l'exécution de ces
                   commandes 
                */
                int indexseq= 0;
                char **cmd;
                while ((cmd= commande->seq[indexseq])) {
                
                    if (cmd[0]) {
                        if (strcmp(cmd[0], "exit") == 0) {
                            fini= true;
                            printf("Au revoir ...\n");
                        }
                        else {
                            printf("commande : ");
                            int indexcmd= 0;
                            while (cmd[indexcmd]) {
                                printf("%s ", cmd[indexcmd]);
                                indexcmd++;
                            }
                            printf("\n");
			     
			    //Création du fils
                            retour = fork();
                            
                            if (retour == -1) {
                            	 //Erreur lors de la création du fils
                                printf("Erreur \n");
                                exit(EXIT_FAILURE);
                                
                            } else if (retour == 0) {
                                //Fils 
                                
                                if (nbCommandes > 1) {
                                	if (indexseq ==0){
                                	    // Redirection de la sortie standard vers le tube
				            dup2(tubes[indexseq][1],1);
                    			    // Fermeture de l'accès en lecture au tube précédent
				            close(tubes[indexseq][0]);
				            
				        } else if (indexseq == nbCommandes-1){
				            // Redirection de l'entrée standard depuis le tube précédent
				            dup2(tubes[indexseq-1][0],0);
                    			    // Fermeture de l'accès en écriture au tube actuel
				            close(tubes[indexseq-1][1]);
				                                        
				        } else {
				            // Redirection des entrées et sorties standards via les tubes
				            dup2(tubes[indexseq][1],1);
				            dup2(tubes[indexseq-1][0],0);
				            close(tubes[indexseq][0]); 
				            close(tubes[indexseq-1][1]);
				        }
				        
				        // Fermeture des descripteurs de fichier inutilisés pour les tubes
				        for (int i=0; i<=nbTubes-2; i++) {
				            //Pour la lecture
				            close(tubes[i][0]);
				            //Pour l'écriture
				            close(tubes[i][1]);
				        }
                                }
		                
		                sigprocmask(SIG_UNBLOCK, &mask, NULL);
                                                
                                if (commande -> backgrounded != NULL) { //on est en avant plan
                                    setpgrp(); //Place le fils dans un groupe ayant les mêmes caractéristiques que le père.
                                    		//Donc on reprend le blocage du père
                                   
                                }
                                
                                // Vérifie si une redirection d'entrée est spécifiée                   
                                if (commande->in != NULL) {
                                    //Ouverture du fichier en lecture uniquement.
                                    int desc_in = open(commande->in, O_RDONLY);
                                    if (desc_in == -1) {
                                    	 //Cas d'erreur lors de l'ouverture
                                        perror("Erreur : Problème lors de l'ouverture du fichier en lecture");
                                        exit(EXIT_FAILURE);
                                    }
                                    //Redirige l'entrée standart vers le fichier
                                    dup2(desc_in, STDIN_FILENO);
                                    //Fermeture du descripteur ouvert
                                    close(desc_in);
                                }

                                // Vérifie si une redirection de sortie est spécifiée                   
                                if (commande->out != NULL) {
                                    //Ouverture du fichier en écriture, le tronquant s'il existe déjà sinon le crée.
                                    int desc_out = open(commande->out, O_WRONLY|O_TRUNC|O_CREAT, 0640);
                                    if (desc_out == -1) {
                                    	 //Cas d'erreur lors de l'ouverture.
                                        perror("Erreur : Problème lors de l'ouverture du fichier en écriture");
                                        exit(EXIT_FAILURE);
                                    }
                                    //Redirige la sortie standart vers le fichier
                                    dup2(desc_out, STDOUT_FILENO);
                                    //Fermeture du descripteur ouvert
                                    close(desc_out);
                                }

                                // Execute la commande avec les arguments saisits                
                                if (execvp(cmd[0], cmd) == -1) {
                                    //Cas d'erreur de l'execution
                                    printf("Erreur \n");
                                    exit(EXIT_FAILURE);
                                } 
                                
                            } else {
                                //Père
                                
                                if ((indexseq == nbCommandes - 1) && (commande -> backgrounded == NULL)) {
                                	for (int i = 0; i<nbTubes ; i++){
		                   		//Fermeture de l'accès écriture et lecture pour chaque tube
		                    		close(tubes[i][0]);
		                    		close(tubes[i][1]);
		                     	}
		                     	
                                	while (!AvantPlanFini) {
                                		pause();
                                	}
                                }  
                            
                            }
                            
                        }
  
                        indexseq++;
                    }
                }
            }
        }
    }
    return EXIT_SUCCESS;
}
