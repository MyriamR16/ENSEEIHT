#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <fcntl.h>
#include <stdbool.h>

//Dans ce cas là, ça ne devrait pas marcher car on crée le fils avant d'avoir 
//crée le tube. Ce qu'après la création du tube, chacun du père et du fils aura 
//son propre tube et donc le fils ne pourra pas lire ce que le père a écrit.

void main (int argc, char *argv[]){
    static int p[2]; 
    int entier = atoi(argv[1]); 
    int entier_lu;
    int pid;
    
    //Création du fils avant le tube
    pid = fork(); 
    
    //Création du tube
    if (pipe(p)== -1){
        //Cas d'erreur : le pipe ne se fait pas.
        perror("pipe");
        exit(EXIT_FAILURE);
    }; 
    
    if (pid == -1) {
        //Cas d'erreur : le fork ne se fait pas.
        perror ("fork");
        exit(EXIT_FAILURE);   
        
    }else if (pid > 0) {
        //Père
        
        //On bloque l'accès lecture au père car celui ci se contente d'écrire dans le tube.
        close(p[0]);
        if (write(p[1], &entier ,sizeof(entier_lu)) == -1) {
            //Cas d'erreur de l'écriture dans le tube de la part du père.
            perror("Problème lors de l'écriture");
            exit(EXIT_FAILURE);
        }
        //On ferme l'accès écriture après avoir écrit.
        close(p[1]); 
        
    }else {
        //fils
        
        //On bloque l'accès écriture au fils car celui ci se contente de lire 
        //ce qu'il y a dans le tube.
        close(p[1]);
        
        if (read(p[0], &entier_lu, sizeof(entier_lu)) == -1) {
            //Cas d'erreur de lecture dans le tube de la part du fils.
            perror("Problème lors de la lecture");
            exit(EXIT_FAILURE);
        }
        //On ferme l'accès lecture après avoir écrit dans le tube.
        close(p[0]);
        
        // Affichage
        printf("L'entier lu dans le tube est : %d\n", entier_lu);
    }
}
